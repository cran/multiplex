%\VignetteIndexEntry{Working with Two-Mode Networks in multiplex}
%\VignetteDepends{multiplex, Rgraphviz}
%\VignetteEngine{knitr::knitr}

\documentclass{article}
\usepackage[a4paper,margin=2.5cm]{geometry}
\usepackage[fleqn]{amsmath}
\usepackage{float}
%
\setlength\parindent{0pt}
\setlength{\parskip}{9pt}
\renewcommand{\baselinestretch}{1.2}
%
\renewcommand\abstractname{}

\begin{document}
\title{\LARGE Working with Two-Mode Networks in `multiplex'}
\author{ {\Large Antonio Rivero Ostoic} \\
{\small School of Business and Social Sciences} \\{\large Aarhus University} }
\maketitle

Social networks are systems defined by a collection of relationships among collective actors. In terms of set theory, a relation is an ordered pair such as $(x, y)$ that refers to a directed linkage from an element $x$ to an element $y$, where $x \in X$ and $y \in Y$ called the domain and codomain of the relation. The context of a binary relation $R$ is the overall relation set that result from the Cartesian product of the domain and codomain or $X \times Y$ of all ordered pairs $(x, y)$ where $R$ is a subset of the context. % X \times Y.

Normally a social network refers to a domain with a set of relations on such domain, which is the generic term used to name the social entities in the system, and in such case, the system of relations is said to be a one-mode network. However, when the domain and the codomain are not equal there are two sets of entities that describe the entire social system, which are known as affiliation, bipartite, or else two-mode networks. %With this kind of networks the entities can be related only to the elements placed in the other set.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<<setup, include=FALSE>>=
knitr::opts_chunk$set(size = 'footnotesize', background = '#FFFFFF', prompt = TRUE, strip.white = FALSE, comment = NA)
options(width=110)
knitr::knit_hooks$set(small.mar = function(before, options, envir) {
    if (before) par(mar = c(4, 4, .1, .1))  # smaller margin on top and right
})
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Galois representation}
In terms of Formal Concept Analysis, the domain and codomain of a two-mode network are characterized respectively as a set of objects $G$, and a set of attributes $M$.\footnote{$G$ is for the German word \textit{Gegenst\"{a}nde} and $M$ for \textit{Merkmale}.} A formal context is obtained with an incident relation $I \subseteq G \times M$ between these sets, and this triple is typically represented as a data table.

<<data, echo=-6>>=
## Fruits data set with attributes
frt <- data.frame(yellow = c(0,1,0,0,1,0,0,0), green = c(0,0,1,0,0,0,0,1), red = c(1,0,0,1,0,0,0,0), 
                  orange = c(0,0,0,0,0,1,1,0), apple = c(1,1,1,1,0,0,0,0), citrus = c(0,0,0,0,1,1,1,1))
## Label the objects
rownames(frt) <- c("PinkLady","GrannySmith","GoldenDelicious","RedDelicious","Lemon","Orange","Mandarin","Lime")
frt
@

\newpage
Certainly another way to obtain such data table of objects and attributes can be with the command \texttt{read.table()} and specifying the names of the rows. Alternatively the function \texttt{read.srt()} will accomplish almost the same by setting the \texttt{attr} argument to \texttt{TRUE} and the \texttt{toarray} argument to \texttt{FALSE}.
<<readtable, eval=FALSE>>=
read.table(file, header=TRUE, 
  row.names=c("PinkLady","GrannySmith","GoldenDelicious","RedDelicious","Lemon","Orange","Mandarin","Lime"))
@
\vspace{-10pt}
<<readsrt, eval=FALSE>>=
read.srt(file, header=TRUE, attr=TRUE, toarray=FALSE)
@
The advantage of the \texttt{read.srt()} function is that the first column does not appear as a ``Factor'' but it is automatically taken as the names of the rows in the data table.


\subsection*{Galois derivations}
The formal concept of a formal context is a pair of sets of objects $A$ and attributes $B$ that is maximally contained on each other. A \emph{Galois derivation} between $G$ and $M$ is defined for any subsets $A \subseteq G$ and $B \subseteq M$ by
\begin{equation*}
\begin{aligned}
A^\prime \;=\; { m \in M \;\mid\; (g, m) \in I \quad(\text{for all } g \in A) } \\
B^\prime \;=\; { g \in G \;\mid\; (g, m) \in I \quad(\text{for all } m \in B) }
\end{aligned}
\end{equation*}
where $A$ and $B$ are said to be the extent and intent of the formal concept respectively, whereas $A^\prime$ is the set of attributes common to all the objects in the intent and $B^\prime$ the set of objects possessing the attributes in the extent.

Starting with version 1.5 it is possible to perform an algebraic analysis of two-mode networks with the function \texttt{galois()} of \textbf{multiplex}.
This command produces an adjunction between the two sets partially ordered by inclusion, and we obtain the complete list of concepts of the context, which can be assigned into an object with the class named \texttt{"Galois"} and \texttt{"full"}.

<<loadmultiplex>>=
## Load first the package
library("multiplex")
@
\vspace{-10pt}
<<galoisFull>>=
## Galois representation between objects and attributes
galois(frt)
@

It is also possible to condense the labeling of the objects and attributes with the option \texttt{"reduced"} in the argument \texttt{labeling} of the \texttt{galois()} function. 
<<galoisReduc, echo=-2>>=
gc <- galois(frt, labeling="reduced")
galois(frt, labeling="reduced")
@


However the full labeling is useful for the construction of the hierarchy of concepts, and it is kept in the structure of the output given by the Galois derivation
<<strgaloisReduc, size='scriptsize'>>=
str(gc$full)
@


\subsection*{Partial ordering of the concepts}

A hierarchy of the concepts is given by the relation subconcept--superconcept 
$$
(A, B) \leq (A_2, B_2) \quad\Leftrightarrow\quad A_1 \subseteq A_2 \qquad (\Leftrightarrow\quad B_1 \subseteq B_2)
$$

For this, the function \texttt{partial.order()} now supports the \texttt{"galois"} option in the \texttt{type} argument where the hierarchy of the concepts is constructed. In this case, even though the concepts have the ``reduced'' option, it is the ``full'' labeling of the formal concepts that is the base of the ordering among these concepts that can be designated in different ways.
<<partialorder>>=
## Partial ordering of the formal concepts with established labels
partial.order(gc, type="galois", labels=paste('c', 1:length(gc$full), sep="_"))
@

In the partial order table we can see that all concepts are included in concept $12$, whereas concept $7$ is included in the rest of the concepts, and hence these are the maxima and the minima of a complete lattice that includes all these concepts. From the outputs given with the Galois derivation of this context we can see as well that these concepts correspond to the set of objects and the set of attributes, which are completely abridged in the reduced formal context.


\subsection*{Concept lattice of the context}

The concept lattice of the formal context is a system of concepts partially ordered where the greatest lower bound of the meet and the least upper bound of the join are defined as
\begin{equation*}
\begin{aligned}
\bigwedge_{t\in T} \quad \bigl(A_t, B_t \bigr) \;=\; \Bigl(\; \bigcap_{t\in T}{A_t}, \;\;\bigl(\bigcup_{t\in T}{B_t} \bigr)^{\prime\prime} \;\Bigr) \\
\bigvee_{t\in T} \quad \bigl(A_t, B_t \bigr) \;=\; \Bigl(\; \bigl(\bigcup_{t\in T}{A_t} \bigr)^{\prime\prime}, \;\;\bigcap_{t\in T}{B_t} \;\Bigr) \\
\end{aligned}
\end{equation*}

We plot this type of lattice diagram with the labeling corresponding to the reduced context.
<<pogc>>= 
## First we assign to an object the partial order of the reduced context
pogc <- partial.order(gc, type="galois")
@
\vspace{-10pt}
<<diagrampogc, fig.pos="H", fig.width=4.5, fig.height=4.5, fig.align='center', fig.cap='Concept Lattice of the fruits and their characteristics', echo=-1, small.mar=TRUE>>=  %
par(mar=c(0,0,0,0))
## Plot the lattice diagram
if( require("Rgraphviz", quietly = TRUE)) {
diagram(pogc)
}
@

Notice that the both objects and attributes not only are given just once (since this is a reduced representation of the context), but the labels are placed instead of the nodes rather than next to them as the typical representation of formal context. Moreover in case that a concept does not have a label, which happens in reduced contexts, then the number of the concept is placed rather than leave blank the node.


\section{Bipartite graphs}

Two-mode network are depicted through bipartite graphs, where the entities can be related only to the elements placed in the other set. One way to produce bipartite graphs with multiplex is by plotting an isomorphic lattice diagram to the bipartite graph. For this we need to construct a square matrix with both the domain and codomain where the binary ties among these are taken as inclusion relations.

For the creation of such matrix we can use the \texttt{transf()} function that starting with version 1.5 supports rectangular arrays. Hence with the option \texttt{"matlist"} of this function we transform the data frame of the formal context into a ``list of pairs'' with the relations between objects and their attributes. It is convenient to preserve the labels in the transformation, and when assigning the output into an object we make sure that the option \texttt{lb2lb} is set to \texttt{TRUE}.

<<lstfrt, echo=-2>>= 
lstfrt <- transf(frt, type="matlist", lb2lb=TRUE)
lstfrt
@

Now if we transform again the list of pairs into a ``matrix'' then we obtain the square array that can be used to produce a lattice diagram isomorphic to the bipartite graph of the network. Since \scalebox{1.6}[1.0]{R} is case sensitive, the output of this transformation differentiates ``orange'' from ``Orange''; otherwise there is a mix of the color with the fruit that will not produce a diagram isomorphic to the bipartite graph. 

<<matlstfrt, echo=TRUE>>=
mlstfrt <- transf(lstfrt, type="listmat", lb2lb=TRUE)
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<<setup2, include=FALSE>>=
# smaller font size for chunks
options(width=130)
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%\vspace{-20pt}
<<matlstfrtecho, echo=FALSE, size='scriptsize'>>=
mlstfrt
@

Notice that this array is a matrix that is asymmetric, and this condition is essential if we want to obtain a partial ordering that leads to the lattice diagram isomorphic to the bipartite graph of the network. Symmetric data structures only consider mutual inclusions without any level differentiation, and hence there will be no lines in the lattice diagram.


If we plot the diagram corresponding to this table, we obtain the lattice diagram that is isomorphic to the bipartite graph of the network. Obviously by transposing the matrix we produce inclusions from the attributes into the objects.

<<bipgraph, fig.pos="H", fig.width=4, fig.height=4, fig.align='center', fig.env='figure', fig.cap='Bipartite graph of the fruit characteristics ', small.mar=TRUE>>=
if( require("Rgraphviz", quietly = TRUE)) {
diagram(mlstfrt)
}
@

<<bipgraphB, fig.pos="H", fig.width=4, fig.height=4, fig.align='center', fig.env='figure', fig.cap='Transpose depiction of the Bipartite graph', small.mar=TRUE>>=
if( require("Rgraphviz", quietly = TRUE)) {
diagram(t(mlstfrt))
}
@



\bigbreak

\renewcommand{\baselinestretch}{1.0}

\begin{thebibliography}{5}
%
\bibitem{Gant-Will96} Ganter, B. and R. Wille~\emph{ Formal Concept Analysis -- Mathematical Foundations}. Springer. 1996.
\bibitem{rgpahviz} Gentry, J, L. Long, R. Gentleman, S. Falcon, F. Hahne, D. Sarkar, and K.D. Hansen  ~\textbf{Rgraphviz}: \emph{Provides plotting capabilities for R graph objects}. R package version 2.6.0
\bibitem{multiplex} Ostoic, J.A.R. ~\textbf{multiplex}: \emph{Analysis of Multiple Social Networks with Algebra}. R package version 1.5
%
\end{thebibliography}


\end{document}
